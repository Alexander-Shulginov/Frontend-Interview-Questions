---
layout: doc
title: CSS
---

# CSS

:::details Что такое блочная модель?

Концепция определяющая структуру и поведение элементов на странице.

Структурно каждый элемент на странице состоит из:

-   Контента (Content)
-   Внутренних отступов (Padding)
-   Границы (Border)
-   Внешних отступов (Margin)

---

Размер элементов рассчитывается исходя из значения свойства `box-sizing`.  
При значении `content-box` учитываются только ширина и высота без учета внутренних отступов и границ, что является контринтуитивно, так как фактический размер не будет соответствовать размеру, отображаемому в devtools.  
Свойство `border-box` при расчете размеров элемента учитывает ширину, высоту и внутренние отступы и границы, решая проблемы свойства `content-box`.

---

По умолчанию все элементы на странице делятся на блочные и строчные.

Блочные:

-   Занимают всю доступную ширину
-   Располагаются друг под другом
-   Им можно задать ширину и высоту

Строчные:

-   Располагаются друг за другом
-   Ширина и высота определяется содержимым, задать напрямую нельзя
-   Внутренние и внешние отступы по вертикали работать не будут

Строчно-блочные:

-   Располагаются друг за другом
-   Можно задать ширину и высоту
-   Внутренние и внешние отступы будут применяться

:::

:::details Что такое специфичность?

Специфичность определяет приоритет с которым будут применяться стили к элементу.

Css предоставляет различные способы для стилизации элементов, а именно:

-   по тегу
-   по классу
-   по атрибуту
-   инлайн

В случае, если один элемент стилизован разными способами, специфичность рассчитывает _вес_ применяемых стилей.  
Правило `!important` отменяет специфичность, применяя стили вне зависимости от специфичности, наследования и т.д.

:::

:::details Что такое наследование?

Это возможность дочерних элементов наследовать, то есть применять, свойства родителей.
По умолчанию наследуются свойства относящиеся к типографике, такие как `font-size`, `color`, `line-height` и тому подобное.

Для управления наследованием существует свойство `inherit`, которое позволяет напрямую наследовать свойства.  
Для свойства `color` существует свойство `currentColor` которое позволяет напрямую наследовать цвет.

`!important` игнорирует наследование применяя стили без учета наследования.

:::

:::details Что такое каскадность?

Механизм определяющий из какого источника и по каким правилам будут применены стили к элементам на странице.

Источники стилей:

-   Браузерные стили с `!important`
-   Инлайновые стили с `!important`
-   Стили при анимации и переходах `animation`, `transition`
-   Обычные инлайновые стили
-   Стили из файлов `.css`
-   Стили браузера по умолчанию

Помимо того откуда приходят стили, каскадность учитывает специфичность и наследование.

:::

:::details Как работает контекст наложения?

Управляет тем, как элементы будут накладываться друг на друга, или же располагаться по оси Z.

Контекст наложения формируется:

-   когда для элемента не статично спозиционирован, то есть, когда задано одно из свойств `position: absolute`, `position: relative`, `position: fixed`
-   когда задано свойство `z-index: 1`
-   когда заданы такие свойства как `opacity`, `transform`, `filter`

Для управления порядком наложения используется свойство `z-index`, элемент с наибольшим значением этого свойства будет располагаться 'выше' других элементов.

Внутри каждого контекста наложения существует свой порядок отрисовки слоев элемента

1. Фон `background` и рамки элемента `border`
1. Элемента с `z-index` со значением меньше 0
1. Блочные элементы `display: block;`
1. Элементы со свойством `float`
1. Инлайновые элементы `display: inline`
1. Элементы со свойством `opacity` меньше 0
1. Элементы со свойством `z-index` больше 0
   :::

:::details Что такое селектор?

Это шаблон, который позволяет выбирать (обращаться к) элементы на странице.

Типы селекторов:

-   Универсальный селектор `*` - выбирает все элементы на странице, кроме псевдоэлементов `::before`, `::after`
-   Селектор по тегу `div`, `p`, `a`
-   Селектор по классу `.nav`, `.button--primary`
-   Селектор по id `#sidebar`, `#item`
-   Селектор по атрибуту `[checked]`, `[type='button']`

Комбинации селекторов:

-   _Группировка_ `.title, h3, .link__text`, селекторы записываются через запятую, стили будут применены к каждому селектору
-   _Объединение_ `div.nav.nav__item` стили будут применены к элементу который содержит все указанные селекторы
-   _Вложенные_ `li a` стилизует самый последний по вложенности селектор
-   _Напрямую вложенные_ `section > h3` стили применяться если `h3` является потомком `section`
-   _Смежные_ `label + input` стили применяться если элементы располагаются на одном уровне вложенности
-   _Последующие_ `span ~ span.color--accent` стили применяться ко всем элементам расположенным слева от `~` если они находятся на одном уровне вложенности

Комбинация селекторов не является хорошей практикой, потому что завязана на структуру элементов на странице. Если один из элементов будет перемещен в другую часть разметки, комбинированные селекторы сломаются.

:::

:::details Что такое поток документа?

Поток документа управляет расположением элементов на странице.

По умолчанию, элементы располагаются в _нормальном потоке_, блочные располагаются друг под другом и занимают всю доступную ширину, строчные располагаются друг за другом, ширина таких элементов равна ширине контента расположенного в них.

Любой элемент можно "вытащить" из нормального потока при помощи `position: absolute;` или `position: fixed;`.

Похожим образом действует свойство `float: left;`, "вытаскивая" элемент из нормального потока, позволяя тексту обтекать его слева или справа.

При `display: flex;` или `display: grid;` расположением элементов управляет родитель без учета нормального потока.

:::

:::details Что такое медиа-выражения?

Медиа-выражения позволяют адаптировать страницу под различные типы устройств на которых она может быть открыта.

Медиа-выражения позволяют стилизовать страницу с учетом:

-   Ширины/высоты устройства
-   Горизонтальной/вертикальной ориентации
-   Темной/светлой темы
-   Плотности пикселей
-   Соотношений сторон экрана
-   Является ли устройство сенсорным или нет

:::

:::details Что такое псевдоэлементы?

Псевдоэлементы - это специальные элементы, которые создаются через css и не существуют в разметке, то есть к ним нельзя обратиться через JavaScript.  
Часто используются для создания визуальных эффектов или оверлеев.

Список псевдоэлементов:

-   `::before`, `::after` самые популярные, добавляют псевдоэлемент перед или после реального элемента
-   `::placeholder` используется для стилизации текста placeholder
-   `::selection` позволяет стилизовать цвет выделения текста
-   `::first-letter`, `::first-line` стилизуют первую букву и первую строку текста

:::

:::details Что такое псевдоклассы?

Псевдоклассы используются для стилизации состояния элементов на странице.
Элементы могут находиться в состоянии:

-   Наведения `:hover`
-   Фокуса `:focus-visible`
-   Отключены `:disabled`
-   Нажаты `:active`
-   Ссылки могут быть посещены `:visited`
-   Чекбоксы могут быть "зачеканы" `:checked`
-   Пустыми `:empty`

Также существуют две специальные группы псевдоклассов `nth-child` и `nth-of-type`.
:::

:::details Для чего используются nth-child и nth-of-type?

Это псевдоклассы позволяющие удобно обращаться к дочерним элементам.

Они позволяют нам:

-   обратиться к перовому или последнему элементу в списке `:first-child`, `:last-child`
-   обратиться к четным или нечетным элементам списка `:nth-child(odd)`, `nth-child(even)`
-   получать элементы в заданном порядке `nth-child(3n)` получим каждый 3й элемент
-   получать элементы в заданном порядке с указанием с какого элемента начинать отсчет `nth-child(3n + 2)` получим каждый 3й элемент начиная со 2го элемента

`nth-child` и `nth-of-type` имеют одинаковые возможности для выбора элементов, разница между ними в том, что `nth-child` работает с любыми дочерними элементами, а `nth-of-type` только с элементами указанного типа.

:::

:::details Расскажите про способы позиционирования элементов на странице?

По умолчанию, в стандартном потоке документа, элементы располагаются в соответствии с правилами блочной модели, блочные элементы друг под другом, строчные друг за другом и тд. Свойство `position` для таких элементов равно `static`.

Для относительного позиционирования используется `position: relative;`, элементу с таким свойством можно задать положение при помощи `top`, `right`, `bottom`, `left`.
Особенностью данного позиционирования является то, что элемент не выходит из стандартного потока, место которое он занимал до позиционирования "сохраняется" за ним.

Для абсолютного позиционирования применяется `position: absolute;` для позиционируемого элемента и `position` с любым из значений `relative`, `absolute`, `fixed` для контейнера в котором позиционируется элемент.
Абсолютно спозиционированный элемент выходит из стандартного потока и может перекрывать другие элементы.

Для фиксированного позиционирования используется `position: fixed;`, элемент с таким свойством будет располагаться относительно окна браузер и при скролле страницы будет оставаться на своем месте.
Фиксированное положение часто применяется для шапки сайта, кнопке "вверх" и виджетов.

Для липкого позиционирования используется свойство `position: sticky`, которое совмещает в себе относительное и фиксированное позиционирование.
По умолчанию "липкий" элемент ведет себя как относительно спозиционированный элемент.
При прокрутке он ведет себя как фиксированный, то есть прилипает к экрану.
Когда контейнер в котором расположен "липкий" элемент будет прокручен, элемент снова станет вести себя как относительно спозиционированный.

:::

:::details Для чего нужны вендорные префиксы?

Вендорные префиксы позволяют браузерам использовать не стандартизированные или экспериментальные css-свойства.

Если какое-либо css-правило внедрено в браузер, но не описано в спецификации, добавляется префикс:

-   `-webkit` - для браузеров на движке WebKit/Blink - Chrome, Opera, Edge, Yandex browser
-   `-moz` - для Firefox
-   `-o` - для Opera (<12 версии)
-   `-ms` - для Microsoft Explorer (<11 версии)

Как правило, вендорные префиксы не прописываются вручную, а используется Autoprefixer, который автоматические проставляет префиксы.

:::

:::details Расскажите про схлопывание margin?

Схлопывание margin происходит, когда у одного элемента задан `margin-bottom`, а у элемента расположенного ниже задан `margin-top`, расстояние между этими элементами не будет суммироваться, а будет равным наибольшему из двух значений.

:::

:::details Что можете рассказать про единицы измерения?

В css единицы измерения разделяются на абсолютные и относительные.  

К абсолютным относятся:
- пиксели `px` самая точная единица измерения
- помимо пикселей существует ряд других единиц измерения, таких как миллиметры, сантиметры, дюймы, пункты, но они редко используются так как пересчитываются в пиксели

К относительным относятся:
- `em` рассчитывает размер на основе размера шрифта родительского элемента, к использованию не рекомендуется, так как при вложенности происходит неконтролируемое изменение размеров дочерних элементов
- `rem` рассчитывает размер относительного размера шрифта корневого `html` элемента, значение которого по умолчанию `16px`
- `%` рассчитывают размер относительно размера родителя
   - `width`, `height`, `padding`, `margin` относительно `width`/`height` родителя
   - `font-size`, `line-height` относительно `font-size` родителя
   - `top`, `right`, `bottom`, `left` относительно спозиционированного родителя
- `vh` рассчитывает размер относительно высоты экрана, на мобильных работает криво, так как не учитывает системные бары
- `vw` рассчитывает размер относительно ширины экрана
- `vmin`, `vmax` рассчитывают размер относительно наименьшей/наибольшей стороны экрана

:::

:::details
Как работает свойство display, и какие значения оно может принимать?

Что такое внутренние и внешние отступы, и как они взаимодействуют?

В чем разница между border-box и content-box?

Как работает свойство overflow?

Что такое clip и clip-path, и как они применяются?

Как работает visibility и чем оно отличается от display: none?

В чем разница между em и rem?

Что такое медиа-запросы, и как их использовать для адаптивной верстки?

Как работает Flexbox, и какова его основная концепция?

Как настроить выравнивание элементов по вертикали с использованием Flexbox?

Чем отличается Flexbox от CSS Grid?

Как создать макет с фиксированными, резиновыми и адаптивными элементами?

Что такое шаблонные области (template areas) в CSS Grid?

Как работает свойство gap?

Как сделать элемент центрированным внутри контейнера с помощью Flexbox?

Какие значения принимает свойство justify-content?

Как работает свойство align-items?

Чем отличаются auto-fill и auto-fit в CSS Grid?

Как работают псевдоэлементы ::before и ::after?

Как задать CSS-анимацию с использованием @keyframes?

Чем отличается transition от animation?

Как работают шаги (steps()) в CSS-анимациях?

Что такое пользовательские свойства CSS (custom properties)?

Как создать темизацию сайта с помощью CSS-переменных?

Что такое CSS-тени (box-shadow и text-shadow), и как их настроить?

Как работает свойство filter?  
 Какие эффекты можно применить?

Что такое миксин в SASS, и как его использовать?

Как работают вложенные правила в SASS или LESS?

В чем разница между SASS и SCSS?

Как использовать переменные и циклы в препроцессорах?

Что такое BEM, и каковы его основные принципы?

Как улучшить производительность CSS?

Что такое критический CSS, и как его использовать?

Как работает CSS-модульность?

Чем отличаются статические, динамические и модульные стили?

Что такое методология ITCSS?

Как работают глобальные и локальные стили в CSS-модулях?

Что такое инлайновые стили, и когда их стоит использовать?

Как работают абсолютные и относительные пути в фонах?

Что такое спрайты в CSS, и как их использовать?

Как сделать адаптивное изображение с помощью свойства object-fit?

В чем разница между min-width, max-width и width?

Как работают свойства aspect-ratio?

Чем отличаются логические свойства (margin-inline, padding-block)?

Что такое кроссбраузерность, и как обеспечить поддержку старых браузеров?

Как работает свойство writing-mode?

Что такое overflow-anchor, и как оно помогает при прокрутке?

Как сделать липкий футер?

Как работает свойство will-change, и в каких случаях его использовать?

Что такое contain, и как оно помогает оптимизировать рендеринг?

Как работает CSS-параллакс?

Что такое CSS Houdini, и какие возможности он предоставляет?

Как настроить анимацию скроллинга (scroll-behavior)?

Что такое prefers-reduced-motion, и как его учитывать?

Как работают свойства backdrop-filter?

Как создать доступное меню на CSS?

Что такое веб-шрифты, и как правильно их подключать?

Какие проблемы могут возникнуть с FOUT/FOIT?

Как улучшить загрузку шрифтов?

Как работают относительные единицы ch и ex?

Что такое шрифт-замена (font-display)?

Чем отличается baseline от других вариантов вертикального выравнивания?

Что такое кастомный курсор в CSS, и как его настроить?

Как работать с анимацией на SVG с помощью CSS?

Как ограничить доступ к стилям для iframe?

Что такое Shadow DOM, и как взаимодействовать с его стилями?

Какие CSS-хаки могут быть полезны для поддержки IE?

Как работают env() и calc() в CSS?

Что такое clip-path: polygon(), и как его использовать?

Как сделать ленивую загрузку изображений на CSS?

Что такое логические свойства в CSS?

Как работает свойство mix-blend-mode?

В чем разница между ::marker и ::before для списков?

Как CSS обрабатывает вложенные списки?

Что такое CSS Scroll Snap, и как его использовать?

Как работает @supports в CSS?

Какие возможности дает @layer в CSS?

Что такое контейнерные запросы (container queries)?

Как работает accent-color для форм?

Что такое appearance, и почему оно может быть полезным?

Как работает кастомизация форм с помощью псевдоклассов?

Что такое hyphens в CSS?

Как работает text-overflow: ellipsis?

Как настроить анимацию с бесконечным повторением?

Какие современные инструменты используют для работы с CSS?

Что такое PostCSS, и для чего он нужен?

:::
