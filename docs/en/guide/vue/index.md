---
layout: doc
title: CSS
---

:::details how to send data on components?

props driling
provide/inject
ref-object
pinia
event bus

:::

::: details Что такое директивы?

Директивы это специальные атрибуты с префиксом `v-` позволяющие динамически управлять DOM деревом на основе реактивных зависимостей.  
Директивы подразделяются на встроенные и пользовательские.
:::

::: details Для чего нужны пользовательские директивы?

Кастомные, они же пользовательские, директивы позволяют создавать переиспользуемую логику управления DOM деревом.  
Используются только тогда, когда нет возможности достичь нужного функционала встроенными директивами.  
Мне нравится использовать кастомные директивы для расширения обработчиков событий, то есть если не существyет нужного события, например события, когда страница проскролена до конца, или событие появления скролла, то я использую кастомные директивы с синтаксисом `v-on-scrollbar-active="someFunction"` или `v-on-scrollbar-on-bottom="someFunction"`
:::

::: details Перечислите встроенные директивы?

-   Для управлением отображения элементов используются  
    `v-if` - управляет наличием в DOM дереве компонента в зависимости от булева значения  
    `v-show` - управляет отображением компонента

-   Для связывания данных с DOM элементами используюся  
    `v-bind` - односторонняя привязка реактивныхданных к DOM элементу  
    `v-model` - двусторонняя привязка данных между моделью и представлением

-   Для итераций используется класcический цикл `for`  
    `v-for` - классический цикл

-   Для обработки событий  
    `v-on` - добавляет событие

-   Для управления содержимым компонента/DOM элемента  
    `v-slot` - содержит идентификатор для именованного слота  
    `v-text` - аналог интерполяции, выводит данные в разметку  
    `v-html` - позволяет вставлять html код, использовать не рекомендуется

-   Для оптимизации производительности  
     `v-once` - позволяет отрисовать элемент или компонент только один раз, последующие обновления будут игнорировать элемент с такой директивой, используется для оптимизации производительности  
     `v-memo` <Badge type="tip" text="v3.2+" vertical="middle" /> - позволяет мемоизировать массив переданных значений, используется как микрооптимизация  
     `v-cloak` - Используется для скрытия еще нескомпилированного шаблона до тех пор, пока он не будет готов  
     `v-pre` - позволяет пропустить DOM элемент на этапе компиляции
    :::

::: details Чем различаются `v-if` и `v-show` и когда что использовать

`v-if` полностью удаляет компонент из DOM-дерева и добавляет его обратно, когда условие становится истинным. Это может быть затратным для производительности при частых изменениях, так как при каждом добавлении или удалении происходит перерисовка и обновление виртуального DOM.  
Однако `v-if` использует механизм ленивой отрисовки — элемент не будет добавлен в DOM, если условие ложное с самого начала.

`v-show` всегда отрисовывает элемент в DOM дереве, но просто скрывает его с помощью `display: none;`  
Используется при частом переключении видимости элемента.
:::

::: details v-bind

Односторонее связывание данных между атрибутами и свойствами компонента.  
Имеет сокращенную записать в виде двоеточия `:`  
Приоритет между нативным атрибутом и атрибом с `v-bind` (начиная с v3.0) будет определяться порядком указания, применяться будет всегда последний указанный атрибут

```vue
<div id="red" v-bind="{ id: 'blue' }"></div>
<!-- результат -->
<div id="blue"></div>

<div v-bind="{ id: 'blue' }" id="red"></div>
<!-- результат -->
<div id="red"></div>
```

:::

::: details v-model

Используется для двухстороннего связывания между моделью и представлением, проще говоря, между данными элементов форм и свойствами объекта.  
Используется только с: `<input>` `<select>` `<textarea>` `компоненты`  
Имеет три модификатора:

-   `lazy` обновление данных произойдет после события `change` а не `input`
-   `number` приводит значения к числу
-   `trim` удаляет пробелы

Начиная с <Badge type="tip" text="v3.4" vertical="middle" /> рекомендуется использовать `defineModel()` который позволяет реализовать двухстороннее связывание между родительским и дочерним компонентами.
:::

::: details v-for

Класcический цикл, итерирует по массивам или объектам.

Требует указания уникального значения `key`, почему?  
По умолчанию Vue взаимодействует с элементами массива по их индексу, и при удалении или добавлении элемента массива индексы сдвигаются что может приводить к ошибкам отображения.  
А так же при обновлении элемента массива, Vue будет искать элемент не по индексу, а по уникальному id, что увеличивает производительность при работе с виртуальным-DOM деревом.

::: info
Нельзя использовать вместе с `v-if`, так как `v-if` имеет больший приоритет
:::

::: details v-on

Позволяет прослушивать события, и выполнять код по их наступлению, имеет сокращение в виде - `@`  
Доступ к объекту события можно получить через `$event`

А так же, директива поддерживает модификаторы:

-   `stop` - останавливает всплытие
-   `prevent` - отменяет дефолтное поведение
-   `self` - вызывает событие непосредственно на самом элементе
-   `once` - событие сработает только 1 раз

И модификаторы системных клавиш `@keyup.ctrl="some"` и так далее
:::

::: details v-text

Обновляет текстовое содержимое DOM элемента, работает через свойство `.textContent` поэтому перезаписывает все содержимое элемента.
:::

::: details v-html

Добавляет html разметку через свойство `.innerHtml`, использовать не рекомендуется по соображениям безопасности.
:::

::: details v-pre

Пропускает компиляцию для элемента и всех его потомков.
:::

::: details v-once

Полезная директива для оптимизации производительности, которая предотвращает повторный рендер компонента или DOM-элемента при обновлении самого компонента или родительского компонента.  
Часто используется на статическом контенте, который не связан с данными, который не имеет состояния, который не должен перерисовываться, ни сам по себе, ни при перерисовки родительского компонента.
:::

::: details v-memo

`Мемоизация` - техника кеширования результатов выполнения функции при вызове ее с одинаковыми входными параметрами.  
Если функция вызывается с одними и теме же параметрами, вместо вычислений, происходит возврат закешированнго значения.

Директива позволяет сохранить результат вычислений между рендерингами, если значения не изменились элемент не будет перерисован.  
:::

::: details v-cloak

Скрывает неотредеренный шаблон, удаляется с компонента когда он будет скомпилирован.

```css
[v-cloak] {
    display: none;
}
```


---
title: Reactivity
---

::: details Что такое реактивность?

Это парадигма программирования, которая реализует автоматическую синхронизацию между моделью (данными) и представлением (интерфейсом). При изменении данных - изменяется интерфейс.
:::

::: details ref()

Оборачивает примитивный тип данных в прокси-объект, делая эти данные реактивными.  
Так как в нативном javascript нет возможности отслеживать изменение данных и их зависимостей, Vue использует прокси-обект который как раз позволяет отслеживать изменения данных и их зависимостей, тем самым реализуя реактивность.
:::

::: details reactive()

Реализует `глубокую реактивность`, оборачивает массивы, объекты любой вложенности, коллекции `Map`, `Set` в прокси-обект, делая значения, в не зависимости от глубины вложенности, реактивными.
:::

::: details Чем отличаются ref от reactie?

Основное отличие в том, что `reactive()` работает с глубоко вложенными объектами.
:::

::: details computed()

Возвращает вычисленное значение, на основе реактивных зависимостей.  
То есть, у нас есть реактивные данные, нам нужно что-то вычислить используя эти реактивные данные, для этого и используется `computed()`, главной особенностью которого является кеширование, которое позволяет возвращать значение из кеша, если реактивные зависимости не менялись.  
По умолчанию вычесленное значение является `readonly`, которое не рекомендуется менять.  
Но также, существует возможность менять реактивные зависимости используя метод `set()`, но данный подход не рекомендуется к использованию.
:::

::: details readonly()

Принимает данные и возвращает их `readonly` копию.
:::

::: details watch()

Наблюдает за указаными реактивными зависимостями, запускает callback при их изменении.  
Конфигурируется при помощи объекта со свойствами

-   `immediate: true` вызывает callback при монтировании компонента
-   `once: true` вызывает callback только один раз
-   `flush: post` дожидается окончания рендеринга компонента и только тогда запускает callback
-   `flush: sync` срабатывает сразу же не дожидаясь рендерига компонета, может вызвать проблемы
:::

::: details watchEffect()

Так же как и `watch()` вызывает callback функцию в ответ на изменение зависимостей, только не требует явного указания зависимостей, все используемые внутри callback функции зависимости автоматически становятся отслеживаемыми.  
Срабатывает сразу, по аналоги с `watch({immediate: true})`

Сокращения:  
`watchEffect()` с параметром `flush: 'post'` - `watchPostEffect()`  
`watchEffect()` с параметром `flush: 'sync'` - `watchSyncEffect()`

Версия <Badge type="tip" text="v3.5+" vertical="middle" /> поддреживает методы для управления наблюдателем:

```ts
const { stop, pause, resume } = watchEffect(() => {});
pause();
resume();
stop();
```
:::

::: details Чем отличаются watch и watchEffect?

`watch()` - требует указания отслеживаемых зависимостей, срабатывает только при изменении зависимостей.  
`watchEffect()` - не требует указания отслеживаемых зависимостей, срабатывает при монтировании компонента.
:::

::: details onWatcherCleanup 3.5+

Регистрирует функцию очистки, которая будет выполняться, когда текущий наблюдатель собирается повторно запуститься или при размонтировании компонента.

Так же для очистки можно использовать `onCleanup()`
:::

::: details isRef()

Проверяет на рекактивность.  
Возвращает `true` если переданный аргемент является реактивным.
:::

::: details unref()

Принимает рективные и литеральные значения, всегда возвращает литерал.

```ts
const reactiveValue = ref(42);
const regularValue = 50;

unref(reactiveValue); // 42
unref(regularValue); // 50
```
:::

::: details toRef() 3.3+

Создает двустронее связывание с конкретным свойством объекта.  
Проще говоря, извлекает свойство объекта в переменную, делая их синхронными, то есть при изменении свойства объекта значение переменной поменяется и наоборот.

```ts
const state = reactive({
    foo: 1,
    bar: 2,
});

const fooRef = toRef(state, 'foo');

fooRef.value++;
console.log(state.foo); // 2

state.foo++;
console.log(fooRef.value); // 3
```
:::

::: details toValue() 3.3+

Так же как и `unref()` возвращает литеральное значение, разница в том, что `unref()` работает только с реактивными данными, а в `toValue()` можно передавать любые методы возвращающие значения.
:::

::: details toRefs()

Преобразует всю свойства объекта в отдельные `ref` ссылки.  
Удобно при деструктуризации.

```ts
const state = reactive({
    name: 'Foo',
    age: 20,
});

const { name, age } = toRefs(state);
```
:::

::: details isProxy() 

Проверяет является ли объект прокси.  
Возвращает `true` если объек создан через `reactive()` или `readonly()`  
:::

::: details isReactive() 

Вернет `true` если объект создан через `reactive()` 
:::

::: details isReadonly()

Вернет `true` если объект создан через `readonly()` 
:::

::: details shallowRef() 

Создает объект, в котором реактивным является только первый уровень вложенности.  
Vue не будет видеть или реагировать на изменения во вложенных свойствах объекта.  
Может использоваться для оптимизации производительности, когда доступ ко вложенным свойствам не является нужным.
:::

::: details triggerRef() 

Используется для обновления неотслеживаемых свойства объекта созданного через `shallwRef`  
:::

::: details customRef()

Позволяет создавать кастомный ref-объект, с возможностью контролировать вызов обновлений и отслеживание зависимостей.  
:::

::: details shallowReactive()

Создает неглубокий `reactive` объект.  
По аналогии с `shallowRef` создается объект у которого реактивным является только первый уровень вложенности.
:::

::: details shallowReadonly() 

Делать только первый уровень объекта `readonly`, вложенные уровни не будет являться `readonly` и их можно будет изменять.  
:::

::: details toRaw() 

Делает из реактивного объекта созданного через `reactive`, `readonly`, `shallowRef`, `shallowReadonly` обычный объект.  
:::

::: details markRaw()

Запрещает объекту становить реактивным.
:::

::: details effectScope()

Создает область действия, которая принимает другие реактивные данные с возможностью уничтожить их, по завершению каких-либо расчетов.  

Как правильно все данные и вычесления удаляются при размонтировании компонента, `effectScope` позволяет напрямую управлять ненужными данными.  
:::

::: details getCurrentScope() 

Возвращает текущую активную область.
:::

::: details onScopeDispose()

Регистрация коллбэка для текущей активной области действия эффекта. Коллбэк будет вызван, когда связанная с ним область действия эффекта будет остановлена.  
