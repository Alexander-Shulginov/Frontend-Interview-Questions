---
title: Reactivity
---

::: details Что такое реактивность?

Это парадигма программирования, которая реализует автоматическую синхронизацию между моделью (данными) и представлением (интерфейсом). При изменении данных - изменяется интерфейс.
:::

::: details ref()

Оборачивает примитивный тип данных в прокси-объект, делая эти данные реактивными.  
Так как в нативном javascript нет возможности отслеживать изменение данных и их зависимостей, Vue использует прокси-обект который как раз позволяет отслеживать изменения данных и их зависимостей, тем самым реализуя реактивность.
:::

::: details reactive()

Реализует `глубокую реактивность`, оборачивает массивы, объекты любой вложенности, коллекции `Map`, `Set` в прокси-обект, делая значения, в не зависимости от глубины вложенности, реактивными.
:::

::: details Чем отличаются ref от reactie?

Основное отличие в том, что `reactive()` работает с глубоко вложенными объектами.
:::

::: details computed()

Возвращает вычисленное значение, на основе реактивных зависимостей.  
То есть, у нас есть реактивные данные, нам нужно что-то вычислить используя эти реактивные данные, для этого и используется `computed()`, главной особенностью которого является кеширование, которое позволяет возвращать значение из кеша, если реактивные зависимости не менялись.  
По умолчанию вычесленное значение является `readonly`, которое не рекомендуется менять.  
Но также, существует возможность менять реактивные зависимости используя метод `set()`, но данный подход не рекомендуется к использованию.
:::

::: details readonly()

Принимает данные и возвращает их `readonly` копию.
:::

::: details watch()

Наблюдает за указаными реактивными зависимостями, запускает callback при их изменении.  
Конфигурируется при помощи объекта со свойствами

-   `immediate: true` вызывает callback при монтировании компонента
-   `once: true` вызывает callback только один раз
-   `flush: post` дожидается окончания рендеринга компонента и только тогда запускает callback
-   `flush: sync` срабатывает сразу же не дожидаясь рендерига компонета, может вызвать проблемы
:::

::: details watchEffect()

Так же как и `watch()` вызывает callback функцию в ответ на изменение зависимостей, только не требует явного указания зависимостей, все используемые внутри callback функции зависимости автоматически становятся отслеживаемыми.  
Срабатывает сразу, по аналоги с `watch({immediate: true})`

Сокращения:  
`watchEffect()` с параметром `flush: 'post'` - `watchPostEffect()`  
`watchEffect()` с параметром `flush: 'sync'` - `watchSyncEffect()`

Версия <Badge type="tip" text="v3.5+" vertical="middle" /> поддреживает методы для управления наблюдателем:

```ts
const { stop, pause, resume } = watchEffect(() => {});
pause();
resume();
stop();
```
:::

::: details Чем отличаются watch и watchEffect?

`watch()` - требует указания отслеживаемых зависимостей, срабатывает только при изменении зависимостей.  
`watchEffect()` - не требует указания отслеживаемых зависимостей, срабатывает при монтировании компонента.
:::

::: details onWatcherCleanup 3.5+

Регистрирует функцию очистки, которая будет выполняться, когда текущий наблюдатель собирается повторно запуститься или при размонтировании компонента.

Так же для очистки можно использовать `onCleanup()`
:::

::: details isRef()

Проверяет на рекактивность.  
Возвращает `true` если переданный аргемент является реактивным.
:::

::: details unref()

Принимает рективные и литеральные значения, всегда возвращает литерал.

```ts
const reactiveValue = ref(42);
const regularValue = 50;

unref(reactiveValue); // 42
unref(regularValue); // 50
```
:::

::: details toRef() 3.3+

Создает двустронее связывание с конкретным свойством объекта.  
Проще говоря, извлекает свойство объекта в переменную, делая их синхронными, то есть при изменении свойства объекта значение переменной поменяется и наоборот.

```ts
const state = reactive({
    foo: 1,
    bar: 2,
});

const fooRef = toRef(state, 'foo');

fooRef.value++;
console.log(state.foo); // 2

state.foo++;
console.log(fooRef.value); // 3
```
:::

::: details toValue() 3.3+

Так же как и `unref()` возвращает литеральное значение, разница в том, что `unref()` работает только с реактивными данными, а в `toValue()` можно передавать любые методы возвращающие значения.
:::

::: details toRefs()

Преобразует всю свойства объекта в отдельные `ref` ссылки.  
Удобно при деструктуризации.

```ts
const state = reactive({
    name: 'Foo',
    age: 20,
});

const { name, age } = toRefs(state);
```
:::

::: details isProxy() 

Проверяет является ли объект прокси.  
Возвращает `true` если объек создан через `reactive()` или `readonly()`  
:::

::: details isReactive() 

Вернет `true` если объект создан через `reactive()` 
:::

::: details isReadonly()

Вернет `true` если объект создан через `readonly()` 
:::

::: details shallowRef() 

Создает объект, в котором реактивным является только первый уровень вложенности.  
Vue не будет видеть или реагировать на изменения во вложенных свойствах объекта.  
Может использоваться для оптимизации производительности, когда доступ ко вложенным свойствам не является нужным.
:::

::: details triggerRef() 

Используется для обновления неотслеживаемых свойства объекта созданного через `shallwRef`  
:::

::: details customRef()

Позволяет создавать кастомный ref-объект, с возможностью контролировать вызов обновлений и отслеживание зависимостей.  
:::

::: details shallowReactive()

Создает неглубокий `reactive` объект.  
По аналогии с `shallowRef` создается объект у которого реактивным является только первый уровень вложенности.
:::

::: details shallowReadonly() 

Делать только первый уровень объекта `readonly`, вложенные уровни не будет являться `readonly` и их можно будет изменять.  
:::

::: details toRaw() 

Делает из реактивного объекта созданного через `reactive`, `readonly`, `shallowRef`, `shallowReadonly` обычный объект.  
:::

::: details markRaw()

Запрещает объекту становить реактивным.
:::

::: details effectScope()

Создает область действия, которая принимает другие реактивные данные с возможностью уничтожить их, по завершению каких-либо расчетов.  

Как правильно все данные и вычесления удаляются при размонтировании компонента, `effectScope` позволяет напрямую управлять ненужными данными.  
:::

::: details getCurrentScope() 

Возвращает текущую активную область.
:::

::: details onScopeDispose()

Регистрация коллбэка для текущей активной области действия эффекта. Коллбэк будет вызван, когда связанная с ним область действия эффекта будет остановлена.  

